(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[324],{24396:(t,i,e)=>{"use strict";e.r(i),e.d(i,{PluginConfigData:()=>PluginConfigData,default:()=>PluginConfigDataModule,getPluginMetadataUrl:()=>C,getPluginUrl:()=>P});var n=e(10385),s=e(15637),a=e(67992),o=e(59279);class PluginConfigData extends a.V{constructor(){super(...arguments),this.name="available-plugin-data",this.availablePlugins=new s.v,this.lastSavedConfiguration=new n.d,this.strict=(0,o.eY)("sesStrict")?["1","true"].includes((0,o.eY)("sesStrict")):null,this.manifestUrl=(0,o.eY)("manifestUrl")}add(t){this.availablePlugins.set(t.name,t)}}var r=e(97542),c=e(57956),u=e(3907);const l="0.0";function g(t){if(!t)return[];const i={[l]:h}["0.0"];if(!i)throw new Error(`[PluginConfigDeserializer] Data with version "${t.version}": not recognized.`);return i(t)}function h(t){return t["0.0"]}const f="0.0";function d(t){const i={[f]:p};if(!t)throw new Error("[PluginConfigSerializer] no data to serialize.");const e=i["0.0"];if(!e)throw new Error('[PluginConfigSerializer] Version "0.0" not recognized.');return e(t)}function p(t){return{[f]:t}}class ConfiguredPluginStore extends u.MU{constructor(t,i,e){super({queue:t,path:`${i}/api/v1/jsonstore/model/plugins/${e}`,batchUpdate:!0,deserialize:g,serialize:d})}}function C(t,i,e){return e+`${t}/${i}/plugin.json`}function P(t,i,e){return e+`${t}/${i}/${t}.js`}class PluginConfigDataModule extends r.Y{constructor(){super(...arguments),this.name="plugin-config"}async init(t,i){if(this.queue=t.queue,this.pluginConfigData=new PluginConfigData,t.loadRegistryAndConfigStore){const e=(await i.getModuleBySymbol(c.y.API)).getApi(),n=await e.getAppKey("showcase","plugin");if(n instanceof Object){const i=n;await this.initializePluginRegistry(i),await this.setupConfigStore(t.baseUrl,t.modelId)}}i.market.register(this,PluginConfigData,this.pluginConfigData)}saveConfig(t,i){const e=this.pluginConfigData.lastSavedConfiguration.values();this.log.debugInfo(`configuration for ${t.id} updated. ${JSON.stringify(e,void 0,2)}`),this.currentStore.update(e)}async setupConfigStore(t,i){this.currentStore=new ConfiguredPluginStore(this.queue,t,i);return this.currentStore.read().then((t=>{t||(t=[]),this.log.debugInfo(`Saved plugin configuration loaded for ${t.length} plugin(s). ${JSON.stringify(t,void 0,2)}`),this.pluginConfigData.lastSavedConfiguration.replace(t),this.pluginConfigData.lastSavedConfiguration.onElementChanged({onAdded:this.saveConfig.bind(this),onUpdated:this.saveConfig.bind(this)})})).catch((t=>this.log.error("Failed to load configured plugins: ",t)))}dispose(t){super.dispose(t),t.market.unregister(this,PluginConfigData),this.pluginConfigData=void 0}async initializePluginRegistry(t){const i=await this.queue.get(this.pluginConfigData.manifestUrl?this.pluginConfigData.manifestUrl:t.manifestUrl,{responseType:"json"}).catch((t=>(this.log.error(t),null)));if(null!==i)for(const e of i.filter((t=>{var i;return!(null===(i=t.versions[t.currentVersion].requiredPolicies)||void 0===i?void 0:i.length)}))){const i=await this.queue.get(C(e.name,e.currentVersion,t.baseUrl),{responseType:"json"}).catch((t=>(this.log.error(t),null)));null!==i&&this.pluginConfigData.add({name:e.name,version:e.currentVersion,config:i.config?i.config:{},applicationKey:i.applicationKey||"unknown-app-key",src:P(e.name,e.currentVersion,t.baseUrl),enabled:!1,strict:null===this.pluginConfigData.strict?i.strict:this.pluginConfigData.strict})}}async getConfiguredPlugins(){const t=await this.currentStore.read()||[],i=[];return t.forEach((t=>{const e=this.pluginConfigData.availablePlugins.get(t.id);if(t.enabled){const n=Object.assign({},t);n.strict=void 0===e.strict?n.strict:e.strict,i.push(n)}})),i}}},3907:(t,i,e)=>{"use strict";e.d(i,{MU:()=>JsonStoreStore});var n,s=e(39880),a=e(44584);!function(t){t.GET="GET",t.POST="POST",t.PATCH="PATCH",t.PUT="PUT",t.DELETE="DELETE",t.OPTIONS="OPTIONS"}(n||(n={}));class ReadOnlyStore extends class Auth{constructor(){this._options={responseType:"json"}}get options(){const t=this._options;return t.headers=(0,a.m)(this.url,this._options.headers||{}),t}}{constructor(t){super(),this.config=t,this.url=t.path}async read(){const{deserialize:t}=this.config;let i=null;return this.config.cachedData&&this.config.cachedData.data?i=this.config.cachedData.data:(i=await this.config.queue.get(this.config.path,this.options),this.config.cachedData&&(this.config.cachedData.data=i)),t(i)}clearCache(){this.config.cachedData&&(this.config.cachedData.data=null)}}class JsonStoreStore extends ReadOnlyStore{constructor(t){super(t),this.config=t,this.acceptsPartial=!1,this.config.batchUpdate="batchUpdate"in this.config&&this.config.batchUpdate}async create(t){throw Error("Not implemented")}updateBatch(t,i){const{serialize:e}=this.config,s=[],a=[...new Set([...Object.keys(t),...Object.keys(i)])];for(const e of a){t[e]||i[e]||s.push(this.config.queue.delete(`${this.config.path}/${e}`,this.options))}const o=e(t,i),r=Object.assign(Object.assign({},this.options),{body:o});return s.push(this.config.queue.request(this.config.httpMethod||n.POST,this.config.path,r)),Promise.all(s)}updateInternal(t,i){const{serialize:e}=this.config,a=[],o=Object.assign({},this.options),r=Object.keys(t),c=Object.keys(i),u=(0,s.XN)(r.concat(c));for(const s in u){const r=u[s],c=t[r]||i[r];if(c){const t={};t[r]=c;const s={},u=i[r];u&&(s[r]=u);const l=e(t,s);o.body=l,a.push(this.config.queue.request(this.config.httpMethod||n.POST,this.config.path,o))}else a.push(this.config.queue.delete(`${this.config.path}/${r}`,this.options))}return Promise.all(a)}async update(t,i){this.clearCache(),await(this.config.batchUpdate?this.updateBatch(t,i||{}):this.updateInternal(t,i||{}))}async delete(t){throw Error("Not implemented")}}}}]);